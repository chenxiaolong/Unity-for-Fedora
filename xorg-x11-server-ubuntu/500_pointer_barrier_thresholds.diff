diff --git a/configure.ac b/configure.ac
index 2693ce7..b5c3880 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2130,6 +2130,25 @@ AC_SUBST([prefix])
 
 AC_CONFIG_COMMANDS([sdksyms], [touch hw/xfree86/sdksyms.dep])
 
+AC_PROG_CXX
+
+PKG_CHECK_MODULES(XORG_GTEST, xorg-gtest,
+        [have_xorg_gtest="yes"],
+        [AC_MSG_WARN([xorg-gtest not installed, tests will not be built])])
+AM_CONDITIONAL([HAVE_XORG_GTEST], [test "x$have_xorg_gtest" = xyes])
+AC_SUBST([XORG_GTEST_CFLAGS])
+AC_SUBST([XORG_GTEST_LIBS])
+
+PKG_CHECK_MODULES([XFIXES], xfixes, [have_xfixes="yes"], [have_xfixes="no"])
+AM_CONDITIONAL([HAVE_XFIXES], [test "x$have_xfixes" = xyes])
+AC_SUBST([XFIXES_CFLAGS])
+AC_SUBST([XFIXES_LIBS])
+
+PKG_CHECK_MODULES([XTEST], xtst, [have_xtest="yes"], [have_xtest="no"])
+AM_CONDITIONAL([HAVE_XTEST], [test "x$have_xtest" = xyes])
+AC_SUBST([XTEST_CFLAGS])
+AC_SUBST([XTEST_LIBS])
+
 AC_OUTPUT([
 Makefile
 glx/Makefile
@@ -2230,6 +2249,7 @@ hw/kdrive/linux/Makefile
 hw/kdrive/src/Makefile
 test/Makefile
 test/xi2/Makefile
+test/gtest/Makefile
 xserver.ent
 xorg-server.pc
 ])
diff --git a/dix/dixutils.c b/dix/dixutils.c
index 9eb5489..bae5fbc 100644
--- a/dix/dixutils.c
+++ b/dix/dixutils.c
@@ -522,7 +522,7 @@ ProcessWorkQueue(void)
         if ((*q->function) (q->client, q->closure)) {
             /* remove q from the list */
             *p = q->next;       /* don't fetch until after func called */
-            free(q);
+            (*q->destroyProc) (q);
         }
         else {
             p = &q->next;       /* don't fetch until after func called */
@@ -542,7 +542,7 @@ ProcessWorkQueueZombies(void)
             (void) (*q->function) (q->client, q->closure);
             /* remove q from the list */
             *p = q->next;       /* don't fetch until after func called */
-            free(q);
+            (*q->destroyProc) (q);
         }
         else {
             p = &q->next;       /* don't fetch until after func called */
@@ -551,6 +551,12 @@ ProcessWorkQueueZombies(void)
     workQueueLast = p;
 }
 
+static void
+FreeWorkQueueItem (WorkQueuePtr this)
+{
+    free(this);
+}
+
 Bool
 QueueWorkProc(Bool (*function)
               (ClientPtr /* pClient */ , pointer /* closure */ ),
@@ -564,12 +570,22 @@ QueueWorkProc(Bool (*function)
     q->function = function;
     q->client = client;
     q->closure = closure;
+    q->destroyProc = FreeWorkQueueItem;
     q->next = NULL;
     *workQueueLast = q;
     workQueueLast = &q->next;
     return TRUE;
 }
 
+Bool
+QueueWorkItem (WorkQueuePtr item)
+{
+    item->next = NULL;
+    *workQueueLast = item;
+    workQueueLast = &item->next;
+    return TRUE;
+}
+
 /*
  * Manage a queue of sleeping clients, awakening them
  * when requested, by using the OS functions IgnoreClient
diff --git a/dix/getevents.c b/dix/getevents.c
index 3093786..c608382 100644
--- a/dix/getevents.c
+++ b/dix/getevents.c
@@ -85,6 +85,12 @@ typedef const char *string;
 InternalEvent *InputEventList = NULL;
 
 /**
+ * xfixes/cursor.c wants the unclamped (x,y) values for velocity
+ * calculation.  Export them here.
+ */
+int unclamped_prex = -1, unclamped_prey = -1;
+
+/**
  * Pick some arbitrary size for Xi motion history.
  */
 int
@@ -916,7 +922,15 @@ positionSprite(DeviceIntPtr dev, int mode, ValuatorMask *mask,
     /* miPointerSetPosition takes care of crossing screens for us, as well as
      * clipping to the current screen. Coordinates returned are in desktop
      * coord system */
+    /*
+     * Hack to pass the unclipped values through to the pointer barrier code.
+     * Required (for now) to calculate the velocity.
+     */
+    unclamped_prex = (int)floor(*screenx) - scr->x;
+    unclamped_prey = (int)floor(*screeny) - scr->y;
     scr = miPointerSetPosition(dev, mode, screenx, screeny);
+    unclamped_prex = -1;
+    unclamped_prey = -1;
 
     /* If we were constrained, rescale x/y from the screen coordinates so
      * the device valuators reflect the correct position. For screen
diff --git a/include/dix.h b/include/dix.h
index 5dc2ac5..78b8a73 100644
--- a/include/dix.h
+++ b/include/dix.h
@@ -245,6 +245,8 @@ extern _X_EXPORT Bool QueueWorkProc(Bool (* /*function */ )(
                                     pointer     /*closure */
     );
 
+extern _X_EXPORT Bool QueueWorkItem(WorkQueuePtr item);
+
 typedef Bool (*ClientSleepProcPtr) (ClientPtr /*client */ ,
                                     pointer /*closure */ );
 
diff --git a/include/dixstruct.h b/include/dixstruct.h
index b2a168a..ba660a3 100644
--- a/include/dixstruct.h
+++ b/include/dixstruct.h
@@ -153,6 +153,9 @@ typedef struct _WorkQueue {
         );
     ClientPtr client;
     pointer closure;
+    void       (*destroyProc) (
+                struct _WorkQueue * /* this */
+);
 } WorkQueueRec;
 
 extern _X_EXPORT TimeStamp currentTime;
diff --git a/include/protocol-versions.h b/include/protocol-versions.h
index 479ac2f..f965d6f 100644
--- a/include/protocol-versions.h
+++ b/include/protocol-versions.h
@@ -122,7 +122,7 @@
 #define SERVER_XF86VIDMODE_MINOR_VERSION	2
 
 /* Fixes */
-#define SERVER_XFIXES_MAJOR_VERSION		5
+#define SERVER_XFIXES_MAJOR_VERSION		6
 #define SERVER_XFIXES_MINOR_VERSION		0
 
 /* X Input */
diff --git a/test/Makefile.am b/test/Makefile.am
index eb61470..29e3fc2 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -7,6 +7,9 @@ if XORG
 SUBDIRS += xi2
 noinst_PROGRAMS += xkb input xtest misc fixes xfree86
 endif
+if HAVE_XORG_GTEST
+SUBDIRS+= gtest
+endif
 check_LTLIBRARIES = libxservertest.la
 
 TESTS=$(noinst_PROGRAMS)
diff --git a/xfixes/cursor.c b/xfixes/cursor.c
index 602b906..cab5b31 100644
--- a/xfixes/cursor.c
+++ b/xfixes/cursor.c
@@ -61,6 +61,7 @@ static RESTYPE CursorClientType;
 static RESTYPE CursorHideCountType;
 static RESTYPE CursorWindowType;
 RESTYPE PointerBarrierType;
+static RESTYPE PointerBarrierClientType;
 static CursorPtr CursorCurrent[MAXDEVICES];
 
 static DevPrivateKeyRec CursorScreenPrivateKeyRec;
@@ -121,6 +122,11 @@ struct PointerBarrierClient {
 };
 
 /*
+ * Pick up unclamped (x,y) coordinates from dix/getevents
+ */
+extern int unclamped_prex, unclamped_prey;
+
+/*
  * Wrap DisplayCursor to catch cursor change events
  */
 
@@ -130,6 +136,7 @@ typedef struct _CursorScreen {
     ConstrainCursorHarderProcPtr ConstrainCursorHarder;
     CursorHideCountPtr pCursorHideCounts;
     struct xorg_list barriers;
+    struct xorg_list barrierClients;
 } CursorScreenRec, *CursorScreenPtr;
 
 #define GetCursorScreen(s) ((CursorScreenPtr)dixLookupPrivate(&(s)->devPrivates, CursorScreenPrivateKey))
@@ -1080,7 +1087,8 @@ barrier_is_blocking(const struct PointerBarrier * barrier,
 
     /* Algorithm below doesn't handle edge cases well, hence the extra
      * checks. */
-    if (barrier_is_vertical(barrier)) {
+        if (barrier_is_vertical(barrier) &&
+	    (dir & (BarrierPositiveX | BarrierNegativeX))) {
         /* handle immediate barrier adjacency, moving away */
         if (dir & BarrierPositiveX && x1 == barrier->x1)
             return FALSE;
@@ -1092,7 +1100,8 @@ barrier_is_blocking(const struct PointerBarrier * barrier,
             return TRUE;
         }
     }
-    else {
+   else if (barrier_is_horizontal(barrier) &&
+		(dir & (BarrierPositiveY | BarrierNegativeY))){
         /* handle immediate barrier adjacency, moving away */
         if (dir & BarrierPositiveY && y1 == barrier->y1)
             return FALSE;
@@ -1191,6 +1200,126 @@ barrier_clamp_to_barrier(struct PointerBarrier *barrier, int dir, int *x,
     }
 }
 
+/*
+ * ConstrainCursorHarder is called from the SIGIO context.
+ * This means we cannot safely send a client event from anything in
+ * CursorConstrainCursorHarder's callgraph.
+ *
+ * Allocate a set of WorkQueue items to use.
+ */
+
+struct BarrierEventStore {
+    WorkQueueRec wq_item;
+    xXFixesBarrierNotifyEvent ev;
+    Bool in_use;
+};
+
+/* Let's guess that 100 events is enough of a buffer. */
+#define BARRIER_EVENT_QUEUE_SIZE 100
+struct BarrierEventStore barrierEventQueue[BARRIER_EVENT_QUEUE_SIZE];
+
+static void
+CursorWorkQueueDestroyProc (WorkQueuePtr this)
+{
+    struct BarrierEventStore *store;
+    store = container_of (this, struct BarrierEventStore, wq_item);
+
+    store->in_use = FALSE;
+}
+
+static Bool
+CursorSendBarrierEvent (ClientPtr client, pointer eventStore)
+{
+    struct BarrierEventStore *store = (struct BarrierEventStore *)eventStore;
+    WriteEventsToClient (client, 1, (xEvent *)&store->ev);
+
+    return TRUE;
+}
+
+static struct BarrierEventStore *
+CursorFindFreeEventStore (void)
+{
+    for (int i = 0; i < BARRIER_EVENT_QUEUE_SIZE; ++i) {
+	if (!barrierEventQueue[i].in_use) {
+	    return &barrierEventQueue[i];
+	}
+    }
+    return NULL;
+}
+
+static void
+QueueBarrierEvent(CursorScreenPtr cs, struct PointerBarrier *barrier,
+		  int x, int y, int velocity, Bool threshold_exceeded)
+{
+    PointerBarrierEventClientPtr client;
+    struct BarrierEventStore *store;
+    xorg_list_for_each_entry(client, &cs->barrierClients, entry) {
+	store = CursorFindFreeEventStore ();
+	if (store == NULL) {
+	    ErrorF ("[xfixes] Barrier event queue full.  Dropping further events\n");
+	    return;
+	}
+
+	store->in_use = TRUE;
+
+	store->ev.type = XFixesEventBase + XFixesBarrierNotify;
+	store->ev.subtype = threshold_exceeded ? XFixesBarrierThresholdExceededNotify :
+					         XFixesBarrierHitNotify;
+	store->ev.event_id = barrier->barrierEventID;
+	store->ev.barrier = barrier->barrier;
+	store->ev.x = x;
+	store->ev.y = y;
+	store->ev.velocity = velocity;
+	store->ev.timestamp = currentTime.milliseconds;
+
+	if (client->client->swapped) {
+
+	    swapl(&store->ev.event_id);
+	    swapl(&store->ev.barrier);
+	    swaps(&store->ev.x);
+	    swaps(&store->ev.y);
+	    swapl(&store->ev.velocity);
+	    swapl(&store->ev.timestamp);
+	}
+
+	store->wq_item.function = CursorSendBarrierEvent;
+	store->wq_item.client = client->client;
+	store->wq_item.closure = store;
+	store->wq_item.destroyProc = CursorWorkQueueDestroyProc;
+
+	QueueWorkItem (&store->wq_item); 
+    }
+}
+
+static void
+barrier_calculate_velocity_components (int x1, int y1, int x2, int y2,
+				       int *vel_x, int *vel_y)
+{
+    static CARD32 last_timestamp = 0;
+    CARD32 timestamp = GetTimeInMillis();
+    int dx, dy;
+    int dt = timestamp - last_timestamp;
+
+    if (last_timestamp == 0) {
+	/* Not much we can do for the first event */
+	*vel_x = 0;
+	*vel_y = 0;
+	last_timestamp = timestamp;
+	return;
+    }
+
+    /* Lets not divide by zero if we can avoid it */
+    dt = dt > 0 ? dt : 1;
+
+    dx = x2 - x1;
+    dy = y2 - y1;
+
+    *vel_x = abs(dx) * 1000.0 / dt;
+    *vel_y = abs(dy) * 1000.0 / dt;
+
+    last_timestamp = timestamp;
+}
+
 static void
 CursorConstrainCursorHarder(DeviceIntPtr dev, ScreenPtr screen, int mode,
                             int *x, int *y)
@@ -1200,12 +1329,23 @@ CursorConstrainCursorHarder(DeviceIntPtr dev, ScreenPtr screen, int mode,
     if (!xorg_list_is_empty(&cs->barriers) && !IsFloating(dev) &&
         mode == Relative) {
         int ox, oy;
+        int vel_x, vel_y;
         int dir;
         struct PointerBarrier *nearest = NULL;
+        PointerBarrierClientPtr c;
 
         /* where are we coming from */
         miPointerGetPosition(dev, &ox, &oy);
 
+        /* Use the unclamped values, if available.  If not, *x, *y
+         * will have to do.
+         * NOTE: We should never get here with unclamped values unset.
+         */
+        if (unclamped_prex == -1 || unclamped_prey == -1) {
+            unclamped_prex = *x;
+            unclamped_prey = *y;
+        }
+
         /* How this works:
          * Given the origin and the movement vector, get the nearest barrier
          * to the origin that is blocking the movement.
@@ -1213,11 +1353,27 @@ CursorConstrainCursorHarder(DeviceIntPtr dev, ScreenPtr screen, int mode,
          * Then, check from the clamped intersection to the original
          * destination, again finding the nearest barrier and clamping.
          */
-        dir = barrier_get_direction(ox, oy, *x, *y);
+        dir = barrier_get_direction(ox, oy, unclamped_prex, unclamped_prey);
+        barrier_calculate_velocity_components(ox, oy, unclamped_prex, unclamped_prey, &vel_x, &vel_y);
 
-        nearest = barrier_find_nearest(cs, dir, ox, oy, *x, *y);
+        nearest = barrier_find_nearest(cs, dir, ox, oy, unclamped_prex, unclamped_prey);
         if (nearest) {
-            barrier_clamp_to_barrier(nearest, dir, x, y);
+	    int velocity = barrier_is_vertical(nearest) ? vel_x : vel_y;
+	    Bool threshold_exceeded = (nearest->velocity != 0) &&
+				      (velocity > nearest->velocity);
+
+	    if (!nearest->lastHit) {
+		/* This is the start of a new barrier event */
+		nearest->barrierEventID++;
+	    }
+
+	    if ((!threshold_exceeded || nearest->lastHit) &&
+		(nearest->barrierEventID != nearest->releaseEventID)) {
+		barrier_clamp_to_barrier(nearest, dir, x, y);
+		nearest->hit = TRUE;
+	    }
+
+	    QueueBarrierEvent(cs, nearest, *x, *y, velocity, threshold_exceeded);
 
             if (barrier_is_vertical(nearest)) {
                 dir &= ~(BarrierNegativeX | BarrierPositiveX);
@@ -1228,11 +1384,31 @@ CursorConstrainCursorHarder(DeviceIntPtr dev, ScreenPtr screen, int mode,
                 oy = *y;
             }
 
-            nearest = barrier_find_nearest(cs, dir, ox, oy, *x, *y);
+            nearest = barrier_find_nearest(cs, dir, ox, oy, unclamped_prex, unclamped_prey);
             if (nearest) {
-                barrier_clamp_to_barrier(nearest, dir, x, y);
+			velocity = barrier_is_vertical(nearest) ? vel_x : vel_y;
+			threshold_exceeded = (nearest->velocity != 0) &&
+						(velocity > nearest->velocity);
+
+			if (!nearest->lastHit) {
+				/* This is the start of a new barrier event */
+				nearest->barrierEventID++;
+			}
+
+			if ((!threshold_exceeded || nearest->lastHit) &&
+				(nearest->barrierEventID != nearest->releaseEventID)) {
+				barrier_clamp_to_barrier(nearest, dir, x, y);
+				nearest->hit = TRUE;
+			}
+
+			QueueBarrierEvent(cs, nearest, *x, *y, velocity, threshold_exceeded);
             }
         }
+
+	xorg_list_for_each_entry(c, &cs->barriers, entry) {
+	    c->barrier.lastHit = c->barrier.hit;
+	    c->barrier.hit = FALSE;
+	}
     }
 
     if (cs->ConstrainCursorHarder) {
@@ -1247,15 +1423,45 @@ CreatePointerBarrierClient(ScreenPtr screen, ClientPtr client,
                            xXFixesCreatePointerBarrierReq * stuff)
 {
     CursorScreenPtr cs = GetCursorScreen(screen);
-    struct PointerBarrierClient *ret = malloc(sizeof(*ret));
+    struct PointerBarrierClient *ret = calloc(sizeof(*ret), 1);
 
     if (ret) {
         ret->screen = screen;
+        ret->barrier.barrier = stuff->barrier;
         ret->barrier.x1 = min(stuff->x1, stuff->x2);
         ret->barrier.x2 = max(stuff->x1, stuff->x2);
         ret->barrier.y1 = min(stuff->y1, stuff->y2);
         ret->barrier.y2 = max(stuff->y1, stuff->y2);
         ret->barrier.directions = stuff->directions & 0x0f;
+	ret->barrier.velocity = 0;
+	ret->barrier.barrierEventID = 0;
+	if (barrier_is_horizontal(&ret->barrier))
+	    ret->barrier.directions &= ~(BarrierPositiveX | BarrierNegativeX);
+	if (barrier_is_vertical(&ret->barrier))
+	    ret->barrier.directions &= ~(BarrierPositiveY | BarrierNegativeY);
+	xorg_list_add(&ret->entry, &cs->barriers);
+    }
+
+    return ret;
+}
+
+static struct PointerBarrierClient *
+CreatePointerBarrierVelocityClient(ScreenPtr screen, ClientPtr client,
+			   xXFixesCreatePointerBarrierVelocityReq *stuff)
+{
+    CursorScreenPtr cs = GetCursorScreen(screen);
+    struct PointerBarrierClient *ret = calloc(sizeof(*ret), 1);
+
+    if (ret) {
+	ret->screen = screen;
+	ret->barrier.barrier = stuff->barrier;
+	ret->barrier.x1 = min(stuff->x1, stuff->x2);
+	ret->barrier.x2 = max(stuff->x1, stuff->x2);
+	ret->barrier.y1 = min(stuff->y1, stuff->y2);
+	ret->barrier.y2 = max(stuff->y1, stuff->y2);
+	ret->barrier.directions = stuff->directions & 0x0f;
+	ret->barrier.velocity = stuff->velocity;
+	ret->barrier.barrierEventID = 0;
         if (barrier_is_horizontal(&ret->barrier))
             ret->barrier.directions &= ~(BarrierPositiveX | BarrierNegativeX);
         if (barrier_is_vertical(&ret->barrier))
@@ -1328,6 +1534,68 @@ SProcXFixesCreatePointerBarrier(ClientPtr client)
     return ProcXFixesVector[stuff->xfixesReqType] (client);
 }
 
+int
+ProcXFixesCreatePointerBarrierVelocity (ClientPtr client)
+{
+    int err;
+    WindowPtr pWin;
+    struct PointerBarrierClient *barrier;
+    struct PointerBarrier b;
+    REQUEST (xXFixesCreatePointerBarrierVelocityReq);
+
+    REQUEST_SIZE_MATCH(xXFixesCreatePointerBarrierVelocityReq);
+    LEGAL_NEW_RESOURCE(stuff->barrier, client);
+
+    err = dixLookupWindow(&pWin, stuff->window, client, DixReadAccess);
+    if (err != Success) {
+	client->errorValue = stuff->window;
+	return err;
+    }
+
+    /* This sure does need fixing. */
+    if (stuff->num_devices)
+	return BadImplementation;
+
+    b.x1 = stuff->x1;
+    b.x2 = stuff->x2;
+    b.y1 = stuff->y1;
+    b.y2 = stuff->y2;
+
+    if (!barrier_is_horizontal(&b) && !barrier_is_vertical(&b))
+	return BadValue;
+
+    /* no 0-sized barriers */
+    if (barrier_is_horizontal(&b) && barrier_is_vertical(&b))
+	return BadValue;
+
+    if (!(barrier = CreatePointerBarrierVelocityClient(pWin->drawable.pScreen,
+						       client, stuff)))
+	return BadAlloc;
+
+    if (!AddResource(stuff->barrier, PointerBarrierType, &barrier->barrier))
+	return BadAlloc;
+
+    return Success;
+}
+
+int
+SProcXFixesCreatePointerBarrierVelocity (ClientPtr client)
+{
+    REQUEST(xXFixesCreatePointerBarrierVelocityReq);
+
+    swaps(&stuff->length);
+    REQUEST_SIZE_MATCH(xXFixesCreatePointerBarrierReq);
+    swapl(&stuff->barrier);
+    swapl(&stuff->window);
+    swaps(&stuff->x1);
+    swaps(&stuff->y1);
+    swaps(&stuff->x2);
+    swaps(&stuff->y2);
+    swapl(&stuff->directions);
+    swapl(&stuff->velocity);
+    return ProcXFixesVector[stuff->xfixesReqType](client);
+}
+
 static int
 CursorFreeBarrier(void *data, XID id)
 {
@@ -1384,6 +1652,116 @@ SProcXFixesDestroyPointerBarrier(ClientPtr client)
     return ProcXFixesVector[stuff->xfixesReqType] (client);
 }
 
+static int
+CursorFreeBarrierClient(void *data, XID id)
+{
+    PointerBarrierEventClientPtr client = data, c;
+    ScreenPtr screen = client->screen;
+    CursorScreenPtr cs = GetCursorScreen(screen);
+
+    /* find and unlink from the screen private */
+    xorg_list_for_each_entry(c, &cs->barrierClients, entry) {
+	if (c == client) {
+	    xorg_list_del(&c->entry);
+	    break;
+	}
+    }
+
+    free(client);
+    return Success;
+}
+
+static struct PointerBarrierEventClient *
+CreatePointerBarrierEventClient(ScreenPtr screen, ClientPtr client,
+				   xXFixesSelectBarrierInputReq *stuff)
+{
+    CursorScreenPtr cs = GetCursorScreen(screen);
+    struct PointerBarrierEventClient *ret = malloc(sizeof(*ret));
+
+    if (ret) {
+	ret->screen = screen;
+	ret->client = client;
+	ret->eventMask = stuff->eventMask;
+	ret->window = stuff->window;
+	ret->resource = FakeClientID (client->index);
+      xorg_list_add(&ret->entry, &cs->barrierClients);
+    }
+
+    return ret;
+}
+
+int
+ProcXFixesSelectBarrierInput (ClientPtr client)
+{
+    int err;
+    WindowPtr pWin;
+    struct PointerBarrierEventClient *eventClient;
+    REQUEST (xXFixesSelectBarrierInputReq);
+
+    REQUEST_SIZE_MATCH(xXFixesSelectBarrierInputReq);
+
+    err = dixLookupWindow(&pWin	, stuff->window, client, DixReadAccess);
+    if (err != Success) {
+	client->errorValue = stuff->window;
+	return err;
+    }
+
+    if (!(eventClient = CreatePointerBarrierEventClient(pWin->drawable.pScreen,
+							client,
+							stuff)))
+      return BadAlloc;
+
+    if (!AddResource (eventClient->resource, PointerBarrierClientType, eventClient))
+      return BadAlloc;
+
+    return Success;
+}
+
+int
+SProcXFixesSelectBarrierInput (ClientPtr client)
+{
+    REQUEST(xXFixesSelectBarrierInputReq);
+
+    swaps(&stuff->length);
+    REQUEST_SIZE_MATCH(xXFixesSelectBarrierInputReq);
+    swapl(&stuff->window);
+    swapl(&stuff->eventMask);
+    return ProcXFixesVector[stuff->xfixesReqType](client);
+}
+
+int
+ProcXFixesBarrierReleasePointer (ClientPtr client)
+{
+    int err;
+    struct PointerBarrier *barrier;
+    REQUEST (xXFixesBarrierReleasePointerReq);
+    REQUEST_SIZE_MATCH(xXFixesBarrierReleasePointerReq);
+
+    err = dixLookupResourceByType((void **)&barrier, stuff->barrier,
+				  PointerBarrierType, client,
+				  DixReadAccess);
+    if (err != Success) {
+	client->errorValue = stuff->barrier;
+	return err;
+    }
+
+    barrier->releaseEventID = stuff->event_id;
+
+    return Success;
+}
+
+int
+SProcXFixesBarrierReleasePointer (ClientPtr client)
+{
+    REQUEST(xXFixesBarrierReleasePointerReq);
+
+    swaps(&stuff->length);
+    REQUEST_SIZE_MATCH(xXFixesBarrierReleasePointerReq);
+    swapl(&stuff->barrier);
+    swapl(&stuff->event_id);
+    return ProcXFixesVector[stuff->xfixesReqType](client);
+}
+
 Bool
 XFixesCursorInit(void)
 {
@@ -1403,6 +1781,7 @@ XFixesCursorInit(void)
         if (!cs)
             return FALSE;
         xorg_list_init(&cs->barriers);
+        xorg_list_init(&cs->barrierClients);
         Wrap(cs, pScreen, CloseScreen, CursorCloseScreen);
         Wrap(cs, pScreen, DisplayCursor, CursorDisplayCursor);
         Wrap(cs, pScreen, ConstrainCursorHarder, CursorConstrainCursorHarder);
@@ -1417,7 +1796,8 @@ XFixesCursorInit(void)
                                              "XFixesCursorWindow");
     PointerBarrierType = CreateNewResourceType(CursorFreeBarrier,
                                                "XFixesPointerBarrier");
-
+    PointerBarrierClientType = CreateNewResourceType(CursorFreeBarrierClient,
+                                               "XFixesPointerBarrierClient");
     return CursorClientType && CursorHideCountType && CursorWindowType &&
-        PointerBarrierType;
+        PointerBarrierType && PointerBarrierClientType;
 }
diff --git a/xfixes/xfixes.c b/xfixes/xfixes.c
index f80230f..36b93b7 100644
--- a/xfixes/xfixes.c
+++ b/xfixes/xfixes.c
@@ -102,6 +102,7 @@ static const int version_requests[] = {
     X_XFixesExpandRegion,       /* Version 3 */
     X_XFixesShowCursor,         /* Version 4 */
     X_XFixesDestroyPointerBarrier,      /* Version 5 */
+    X_XFixesBarrierReleasePointer, /* Version 6 */
 };
 
 #define NUM_VERSION_REQUESTS	(sizeof (version_requests) / sizeof (version_requests[0]))
@@ -140,7 +141,11 @@ int (*ProcXFixesVector[XFixesNumberRequests]) (ClientPtr) = {
 /*************** Version 4 ****************/
         ProcXFixesHideCursor, ProcXFixesShowCursor,
 /*************** Version 5 ****************/
-ProcXFixesCreatePointerBarrier, ProcXFixesDestroyPointerBarrier,};
+ProcXFixesCreatePointerBarrier, ProcXFixesDestroyPointerBarrier,
+/*************** Version 6 ****************/
+        ProcXFixesCreatePointerBarrierVelocity,
+        ProcXFixesSelectBarrierInput,
+        ProcXFixesBarrierReleasePointer,};
 
 static int
 ProcXFixesDispatch(ClientPtr client)
@@ -200,7 +205,11 @@ static int (*SProcXFixesVector[XFixesNumberRequests]) (ClientPtr) = {
 /*************** Version 4 ****************/
         SProcXFixesHideCursor, SProcXFixesShowCursor,
 /*************** Version 5 ****************/
-SProcXFixesCreatePointerBarrier, SProcXFixesDestroyPointerBarrier,};
+SProcXFixesCreatePointerBarrier, SProcXFixesDestroyPointerBarrier,
+/*************** Version 6 ****************/
+        SProcXFixesCreatePointerBarrierVelocity,
+        SProcXFixesSelectBarrierInput,
+        SProcXFixesBarrierReleasePointer,};
 
 static int
 SProcXFixesDispatch(ClientPtr client)
diff --git a/xfixes/xfixes.h b/xfixes/xfixes.h
index 19af09f..fc7c3c4 100644
--- a/xfixes/xfixes.h
+++ b/xfixes/xfixes.h
@@ -28,6 +28,7 @@
 #define _XFIXES_H_
 
 #include "resource.h"
+#include "list.h"
 
 extern _X_EXPORT RESTYPE RegionResType;
 extern _X_EXPORT RESTYPE PointerBarrierType;
@@ -52,9 +53,25 @@ extern _X_EXPORT int XFixesErrorBase;
 extern _X_EXPORT RegionPtr
  XFixesRegionCopy(RegionPtr pRegion);
 
+typedef struct PointerBarrierEventClient *PointerBarrierEventClientPtr;
+
+struct PointerBarrierEventClient {
+    ScreenPtr screen;
+    ClientPtr client;
+    CARD32    eventMask;
+    XID window;
+    XID resource;
+    struct xorg_list entry;
+};
+
 struct PointerBarrier {
+    XID    barrier;
     CARD16 x1, x2, y1, y2;
     CARD32 directions;
+    CARD32 velocity;
+    CARD32 barrierEventID;
+    CARD32 releaseEventID;
+    Bool   hit, lastHit;
 };
 
 extern int
diff --git a/xfixes/xfixesint.h b/xfixes/xfixesint.h
index 71f88a9..8b204dc 100644
--- a/xfixes/xfixesint.h
+++ b/xfixes/xfixesint.h
@@ -59,6 +59,7 @@
 #include "windowstr.h"
 #include "selection.h"
 #include "xfixes.h"
+#include "list.h"
 
 extern int XFixesEventBase;
 
@@ -295,6 +296,26 @@ int
 int
  SProcXFixesDestroyPointerBarrier(ClientPtr client);
 
+/* Version 6 */
+
+int
+ProcXFixesSelectBarrierInput (ClientPtr client);
+
+int
+SProcXFixesSelectBarrierInput (ClientPtr client);
+
+int
+ProcXFixesCreatePointerBarrierVelocity (ClientPtr client);
+
+int
+SProcXFixesCreatePointerBarrierVelocity (ClientPtr client);
+
+int
+ProcXFixesBarrierReleasePointer (ClientPtr client);
+
+int
+SProcXFixesBarrierReleasePointer (ClientPtr client);
+
 /* Xinerama */
 extern int (*PanoramiXSaveXFixesVector[XFixesNumberRequests]) (ClientPtr);
 void PanoramiXFixesInit(void);
diff --git a/dix/dixutils.c b/dix/dixutils.c
index 9eb5489..521bdce 100644
diff -Nru /dev/null xorg-server/test/gtest/dummy.conf
--- /dev/null	1970-01-01 01:00:00.000000000 +0100
+++ xorg-server/test/gtest/dummy.conf	2012-05-21 18:00:45.996945542 +0200
@@ -0,0 +1,4 @@
+Section "Device"
+    Identifier "Dummy video device"
+    Driver "dummy"
+EndSection
diff -Nru /dev/null xorg-server/test/gtest/Makefile.am
--- /dev/null	1970-01-01 01:00:00.000000000 +0100
+++ xorg-server/test/gtest/Makefile.am	2012-05-21 18:00:45.996545542 +0200
@@ -0,0 +1,27 @@
+check_PROGRAMS = xfixes_barriers
+check_DATA = dummy.conf
+
+TESTS=xfixes_barriers
+
+GTEST_SRC_DIR = /usr/src/gtest
+GTEST_SOURCES = $(GTEST_SRC_DIR)/src/gtest-all.cc
+
+xfixes_barriers_CXXFLAGS = $(AM_CXXFLAGS) \
+	-I$(GTEST_SRC_DIR) \
+	$(XORG_GTEST_CFLAGS) \
+	$(XTEST_CFLAGS) \
+	$(XFIXES_CFLAGS) \
+	-DXORG_BINARY=\"$(top_builddir)/hw/xfree86/Xorg\" \
+	-DXORG_DUMMY_CONF=\"$(abs_srcdir)/dummy.conf\"
+
+xfixes_barriers_LDADD = \
+	$(XFIXES_LIBS) \
+	$(XTEST_LIBS) \
+	$(XORG_GTEST_LIBS) \
+	-lpthread
+
+xfixes_barriers_SOURCES = \
+	xfixes_barriers.cpp
+
+nodist_xfixes_barriers_SOURCES = \
+	$(GTEST_SOURCES)
diff -Nru /dev/null xorg-server/test/gtest/xfixes_barriers.cpp
--- /dev/null	1970-01-01 01:00:00.000000000 +0100
+++ xorg-server/test/gtest/xfixes_barriers.cpp	2012-05-21 18:00:45.995445542 +0200
@@ -0,0 +1,828 @@
+/*
+
+Copyright (c) 2012, Canonical Ltd
+
+Permission is hereby granted, free of charge, to any person obtaining a
+copy of this software and associated documentation files (the "Software"),
+to deal in the Software without restriction, including without limitation
+the rights to use, copy, modify, merge, publish, distribute, sublicense,
+and/or sell copies of the Software, and to permit persons to whom the
+Software is furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice (including the next
+paragraph) shall be included in all copies or substantial portions of the
+Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+DEALINGS IN THE SOFTWARE.
+*/
+
+#include <iostream>
+#include <sys/time.h>
+#include <unistd.h>
+#include <gtest/gtest.h>
+#include <xorg/gtest/test.h>
+#include <xorg/gtest/environment.h>
+#include <X11/Xlib.h>
+#include <X11/extensions/XTest.h>
+#include <X11/extensions/Xfixes.h>
+
+
+int main (int argc, char **argv)
+{
+    ::testing::InitGoogleTest (&argc, argv);
+    xorg::testing::Environment* environment = new xorg::testing::Environment ();
+    environment->set_conf_file (XORG_DUMMY_CONF);
+    environment->set_server (XORG_BINARY);
+    testing::AddGlobalTestEnvironment (environment);
+    return RUN_ALL_TESTS ();
+}
+
+class BarrierTest : public xorg::testing::Test {
+    public:
+    ::Display *dpy;
+    static XErrorEvent *lastError;
+    int xtest_eventbase;
+    int xtest_errorbase;
+    int fixes_eventbase;
+    int fixes_errorbase;
+
+    void AssertPointerPosition (int expected_x, int expected_y)
+    {
+        int x, y, unused_int;
+        unsigned int unused_uint;
+        Window unused_win;
+
+        XQueryPointer (Display (), DefaultRootWindow (Display ()),
+                       &unused_win, &unused_win, &x, &y,
+                       &unused_int, &unused_int, &unused_uint);
+
+        ASSERT_TRUE (x == expected_x && y == expected_y) <<
+            "Incorrect pointer position: Expected ("<<
+            expected_x<< ", "<<expected_y<<"), got "<<
+            "("<<x<<", "<<y<<")\n";
+    }
+
+    bool WaitForXEvent (int msTimeout = 1000)
+    {
+        fd_set fds;
+        int xfd = ConnectionNumber (Display ());
+        struct timeval tv;
+        int retval;
+
+        FD_ZERO (&fds);
+        FD_SET (xfd, &fds);
+
+        tv.tv_sec = msTimeout / 1000;
+        tv.tv_usec = (msTimeout % 1000) * 1000;
+
+        retval = select (xfd + 1, &fds, NULL, NULL, &tv);
+
+        EXPECT_NE (-1, retval)<<"Error waiting for X event";
+
+        return retval;
+    }
+
+    protected:
+    virtual void SetUp ()
+    {
+        ASSERT_NO_FATAL_FAILURE (xorg::testing::Test::SetUp());
+
+        dpy = Display ();
+        int major = 2, minor = 2;
+        ASSERT_TRUE (XTestQueryExtension (dpy,
+                                          &xtest_eventbase, &xtest_errorbase,
+                                          &major, &minor));
+        ASSERT_EQ (2, major);
+        ASSERT_TRUE (minor >= 2);
+
+        major = 6;
+        minor = 0;
+        XFixesQueryVersion (dpy, &major, &minor);
+        ASSERT_EQ (6, major);
+        ASSERT_TRUE (minor >= 0);
+
+        ASSERT_TRUE (XFixesQueryExtension (dpy,
+                                           &fixes_eventbase, &fixes_errorbase));
+
+        lastError = new XErrorEvent;
+        XSetErrorHandler (ErrorHandler);
+    }
+
+    private:
+    static int ErrorHandler (::Display *dpy, XErrorEvent *error)
+    {
+        memcpy (lastError, error, sizeof (*lastError));
+        return 0;
+    }
+};
+
+XErrorEvent *BarrierTest::lastError = NULL;
+
+TEST_F (BarrierTest, CreateVerticalBarrierSucceeds)
+{
+    PointerBarrier barrier;
+    barrier = XFixesCreatePointerBarrier (dpy, DefaultRootWindow(dpy),
+                                          100, 0,
+                                          100, 100,
+                                          0,
+                                          0, NULL);
+    ASSERT_NE(None, barrier);
+}
+
+TEST_F (BarrierTest, CreateHorizontalBarrierSucceds)
+{
+    PointerBarrier barrier;
+    barrier = XFixesCreatePointerBarrier (dpy, DefaultRootWindow(dpy),
+                                          100, 100,
+                                          200, 100,
+                                          0,
+                                          0, NULL);
+    ASSERT_NE(None, barrier);
+}
+
+TEST_F (BarrierTest, CreateNonAxisAlignedBarrierFails)
+{
+    XFixesCreatePointerBarrier (dpy, DefaultRootWindow(dpy),
+                                0, 0,
+                                100, 100,
+                                0,
+                                0, NULL);
+    XSync (Display (), false);
+    ASSERT_EQ(BadValue, lastError->error_code);
+}
+
+TEST_F (BarrierTest, VerticalBidirectionalBarrierBlocksRelativeMotion)
+{
+    int barrier_x = 100;
+    XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                                barrier_x, 0,
+                                barrier_x, 300,
+                                0, 0, NULL);
+
+    int x = 200, y = 100, dx = -200, dy = 0;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // Relative motion should block on barrier
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (barrier_x, y));
+}
+
+TEST_F (BarrierTest, VerticalPositiveXBarrierBlocksMotion)
+{
+    int barrier_x = 100;
+    XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                                barrier_x, 0,
+                                barrier_x, 300,
+                                BarrierPositiveX, 0, NULL);
+    int x = 200, y = 100, dx = -200, dy = 0;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // Relative motion in -ve X direction should block on barrier
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (barrier_x, y + dy));
+
+    x = 0, y = 100, dx = 200, dy = 0;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // Relative motion in +ve X direction should ignore barrier
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, y + dy));
+}
+
+TEST_F (BarrierTest, VerticalNegativeXBarrierBlocksMotion)
+{
+    int barrier_x = 100;
+    XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                                barrier_x, 0,
+                                barrier_x, 300,
+                                BarrierNegativeX,
+                                0, NULL);
+
+    int x = 200, y = 100, dx = -200, dy = 0;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // Relative motion in -ve X direction should ignore barrier
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, y + dy));
+
+    x = 0, y = 100, dx = 200, dy = 0;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // Relative motion in +ve X direction should block on barrier
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (barrier_x - 1, y + dy));
+}
+
+TEST_F (BarrierTest, HorizontalBidirectionalBarrierBlocksRelativeMotion)
+{
+    int barrier_y = 100;
+    XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                                0,   barrier_y,
+                                300, barrier_y,
+                                0, 0, NULL);
+
+    int x = 200, y = 0;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // Relative motion in +ve Y direction should block on barrier
+    int dx = 0, dy = 200;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, barrier_y - 1));
+
+    x = 100, y = 200;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // Relative motion in -ve Y direction should block on barrier
+    dx = 0, dy = -200;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, barrier_y));
+}
+
+TEST_F (BarrierTest, HorizontalPositiveYBarrierBlocksMotion)
+{
+    int barrier_y = 100;
+    XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                                0,   barrier_y,
+                                300, barrier_y,
+                                BarrierPositiveY, 0, NULL);
+
+    int x = 200, y = 0;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // Relative motion in +ve Y direction should ignore barrier
+    int dx = 0, dy = 200;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, y + dy));
+
+    x = 100, y = 200;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // Relative motion in -ve Y direction should block on barrier
+    dx = 0, dy = -200;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, barrier_y));
+}
+
+TEST_F (BarrierTest, HorizontalNegativeYBarrierBlocksMotion)
+{
+    int barrier_y = 100;
+    XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                                0,   barrier_y,
+                                300, barrier_y,
+                                BarrierNegativeY, 0, NULL);
+
+    int x = 200, y = 0;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // Relative motion in +ve Y direction should block on barrier
+    int dx = 0, dy = 200;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, barrier_y - 1));
+
+    x = 100, y = 200;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // Relative motion in -ve Y direction should ignore barrier
+    dx = 0, dy = -200;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, y + dy));
+}
+
+TEST_F (BarrierTest, DestroyPointerBarrierSucceeds)
+{
+    int barrier_x = 100;
+    PointerBarrier barrier;
+    barrier = XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                                          barrier_x, 0,
+                                          barrier_x, 300,
+                                          0, 0, NULL);
+
+    int x = 0, y = 200;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // Check that the barrier exists before we destroy it.
+    int dx = 200, dy = 0;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (barrier_x - 1, y + dy));
+
+    // Destroy the barrier...
+    XFixesDestroyPointerBarrier (Display (), barrier);
+
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // There should be no barrier to block this.
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, y + dy));
+}
+
+TEST_F (BarrierTest, BarrierIgnoresNonsensicalDirections)
+{
+    int barrier_x = 100;
+    XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                                barrier_x, 0,
+                                barrier_x, 300,
+                                BarrierPositiveY | BarrierNegativeY,
+                                0, NULL);
+
+    int x = 200, y = 100;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    int dx = -200, dy = 0;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (barrier_x, y + dy));
+
+    int barrier_y = 100;
+    XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                               0,   barrier_y,
+                               400, barrier_y,
+                               BarrierPositiveX | BarrierNegativeX,
+                               0, NULL);
+
+    x = 100, y = 200;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    dx = 0, dy = -200;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, barrier_y));
+}
+
+TEST_F (BarrierTest, VerticalBarrierEdges)
+{
+    int barrier_x = 300, barrier_y1 = 300 , barrier_y2 = 500;
+    XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                                barrier_x, barrier_y1,
+                                barrier_x, barrier_y2,
+                                0, 0, NULL);
+
+    int x = barrier_x + 100, y = barrier_y1 - 1;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // Motion should take us past the top of the barrier...
+    int dx = -200, dy = 0;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, y + dy));
+
+    x = barrier_x + 100, y = barrier_y1;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // Motion should hit the top of the barrier...
+    dx = -200, dy = 0;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (barrier_x, y + dy));
+
+    x = barrier_x + 100, y = barrier_y2;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // Motion should hit the bottom of the barrier...
+    dx = -200, dy = 0;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (barrier_x, y + dy));
+
+    x = barrier_x + 100, y = barrier_y2 + 1;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // Motion should take us past the bottom of the barrier...
+    dx = -200, dy = 0;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, y + dy));
+}
+
+TEST_F (BarrierTest, HorizontalBarrierEdges)
+{
+    int barrier_x1 = 200, barrier_x2 = 500, barrier_y = 300;
+    XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                                barrier_x1, barrier_y,
+                                barrier_x2, barrier_y,
+                                0, 0, NULL);
+
+    int x = barrier_x1 - 1, y = barrier_y - 100;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // Motion should take us past the left edge of the barrier...
+    int dx = 0, dy = 200;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, y + dy));
+
+    x = barrier_x1, y = barrier_y - 100;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // Motion should hit the top of the barrier...
+    dx = 0, dy = 200;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, barrier_y - 1));
+
+    x = barrier_x2, y = barrier_y - 100;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // Motion should hit the bottom of the barrier...
+    dx = 0, dy = 200;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, barrier_y - 1));
+
+    x = barrier_x2 + 1, y = barrier_y - 100;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // Motion should take us past the bottom of the barrier...
+    dx = 0, dy = 200;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, y + dy));
+}
+
+TEST_F (BarrierTest, CornerBlocksMotion)
+{
+    int corner_x, corner_y;
+    XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                                corner_x, corner_y,
+                                corner_x, corner_y + 300,
+                                0, 0, NULL);
+    XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                                corner_x, corner_y,
+                                corner_x + 300, corner_y,
+                                0, 0, NULL);
+
+    int x = corner_x + 100, y = corner_y + 100;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    XTestFakeRelativeMotionEvent (Display (), -200, -200, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (corner_x, corner_y));
+}
+
+TEST_F (BarrierTest, VerticalBarrierWithAdjacentStart)
+{
+    int barrier_x = 350;
+    XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                                barrier_x, 100,
+                                barrier_x, 300,
+                                0, 0, NULL);
+
+    int x = barrier_x, y = 200;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    int dx = -10, dy = 0;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (barrier_x, y + dy));
+
+    x = barrier_x, y = 200;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    dx = 10, dy = 0;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, y + dy));
+
+    x = barrier_x - 1, y = 200;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    dx = 10, dy = 0;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (barrier_x - 1, y + dy));
+
+    x = barrier_x - 1, y = 200;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    dx = -10, dy = 0;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, y + dy));
+}
+
+TEST_F (BarrierTest, HorizontalBarrierWithAdjacentStart)
+{
+    int barrier_y = 300;
+    XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                                100, barrier_y,
+                                400, barrier_y,
+                                0, 0, NULL);
+
+    int x = 240, y = barrier_y;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    int dx = 0, dy = -10;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, barrier_y));
+
+    x = 240, y = barrier_y;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    dx = 0, dy = 10;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, y + dy));
+
+    x = 240, y = barrier_y - 1;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    dx = 0, dy = 10;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, barrier_y - 1));
+
+    x = 240, y = barrier_y - 1;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    dx = 0, dy = -10;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, y + dy));
+}
+
+TEST_F (BarrierTest, BarrierNotifyEventFires)
+{
+    int barrier_y = 300;
+    XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                                100, barrier_y,
+                                400, barrier_y,
+                                0, 0, NULL);
+
+    XFixesSelectBarrierInput (Display (), DefaultRootWindow (Display ()),
+                              XFixesBarrierHitNotifyMask);
+
+    int x = 240, y = barrier_y + 50;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    XTestFakeRelativeMotionEvent (Display (), 0, -100, 0);
+
+    XFlush (Display ());
+    ASSERT_TRUE (WaitForXEvent ())<<"Timed out waiting to receive X event";
+    while (XPending (Display ())) {
+        XEvent e;
+        XNextEvent (Display (), &e);
+        switch (e.xany.type - fixes_eventbase) {
+            case XFixesBarrierNotify:
+                return;
+        }
+    }
+    FAIL () << "Failed to recieve BarrierNotify event";
+}
+
+TEST_F (BarrierTest, RecieveOneNotifyEventPerHit)
+{
+    int barrier_x = 100;
+    XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                                barrier_x, 0,
+                                barrier_x, 300,
+                                0, 0, NULL);
+
+    XFixesSelectBarrierInput (Display (), DefaultRootWindow (Display ()),
+                              XFixesBarrierHitNotifyMask);
+
+    int x = 200, y = 100, dx = -200, dy = 0;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    /* Generate 5 barrier events */
+    for (int i = 0; i < 5; ++i) {
+        XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    }
+
+    int barrierEventCount = 0;
+    XFlush (Display ());
+    ASSERT_TRUE (WaitForXEvent ())<<"Timed out waiting to receive X event";
+    while (XPending (Display ())) {
+        XEvent e;
+        XNextEvent (Display (), &e);
+        switch (e.xany.type - fixes_eventbase) {
+            case XFixesBarrierNotify:
+                barrierEventCount++;
+                break;
+        }
+    }
+    ASSERT_EQ (5, barrierEventCount);
+}
+
+TEST_F (BarrierTest, BarrierEventHasNonZeroVelocity)
+{
+    int barrier_x = 100;
+    XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                                barrier_x, 0,
+                                barrier_x, 300,
+                                0, 0, NULL);
+
+    XFixesSelectBarrierInput (Display (), DefaultRootWindow (Display ()),
+                              XFixesBarrierHitNotifyMask);
+
+    int x = 200, y = 100, dx = -200, dy = 0;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    /* One relative event to ensure the server has a non-zero
+     * last-event-time */
+    XTestFakeRelativeMotionEvent (Display (), 10, 10, 0);
+    /* Run the pointer into the barrier */
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+
+    XFlush (Display ());
+    ASSERT_TRUE (WaitForXEvent ())<<"Timed out waiting to receive X event";
+    while (XPending (Display ())) {
+        XEvent e;
+        XNextEvent (Display (), &e);
+        switch (e.xany.type - fixes_eventbase) {
+            case XFixesBarrierNotify:
+                XFixesBarrierNotifyEvent *notify = (XFixesBarrierNotifyEvent *)&e;
+                ASSERT_LT (0, notify->velocity);
+                return;
+        }
+    }
+    FAIL () << "Failed to receive barrier event";
+}
+
+TEST_F (BarrierTest, ScreenEdgeVerticalBarrierEventHasNonZeroVelocity)
+{
+    int barrier_x = 0;
+    XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                                barrier_x, 0,
+                                barrier_x, 300,
+                                0, 0, NULL);
+
+    XFixesSelectBarrierInput (Display (), DefaultRootWindow (Display ()),
+                              XFixesBarrierHitNotifyMask);
+
+    int x = 100, y = 100, dx = -200, dy = 0;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    /* One relative event to ensure the server has a non-zero
+     * last-event-time */
+    XTestFakeRelativeMotionEvent (Display (), 10, 10, 0);
+    /* Run the pointer into the barrier */
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+
+    XFlush (Display ());
+    ASSERT_TRUE (WaitForXEvent ())<<"Timed out waiting to receive X event";
+    while (XPending (Display ())) {
+        XEvent e;
+        XNextEvent (Display (), &e);
+        switch (e.xany.type - fixes_eventbase) {
+            case XFixesBarrierNotify:
+                XFixesBarrierNotifyEvent *notify = (XFixesBarrierNotifyEvent *)&e;
+                ASSERT_LT (0, notify->velocity);
+                return;
+        }
+    }
+    FAIL () << "Failed to receive barrier event";
+}
+
+TEST_F (BarrierTest, ScreenEdgeHorizontalBarrierEventHasNonZeroVelocity)
+{
+    int barrier_y = 0;
+    XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                                0, barrier_y,
+                                300, barrier_y,
+                                0, 0, NULL);
+
+    XFixesSelectBarrierInput (Display (), DefaultRootWindow (Display ()),
+                              XFixesBarrierHitNotifyMask);
+
+    int x = 100, y = 100, dx = 0, dy = -200;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    /* One relative event to ensure the server has a non-zero
+     * last-event-time */
+    XTestFakeRelativeMotionEvent (Display (), 10, 10, 0);
+    /* Run the pointer into the barrier */
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+
+    XFlush (Display ());
+    ASSERT_TRUE (WaitForXEvent ())<<"Timed out waiting to receive X event";
+    while (XPending (Display ())) {
+        XEvent e;
+        XNextEvent (Display (), &e);
+        switch (e.xany.type - fixes_eventbase) {
+            case XFixesBarrierNotify:
+                XFixesBarrierNotifyEvent *notify = (XFixesBarrierNotifyEvent *)&e;
+                ASSERT_LT (0, notify->velocity);
+                return;
+        }
+    }
+    FAIL () << "Failed to receive barrier event";
+}
+
+TEST_F (BarrierTest, ReceiveOneBarrierEventPerHitOnScreenEdge)
+{
+    int barrier_x = 0;
+    XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                                barrier_x, 0,
+                                barrier_x, 300,
+                                0, 0, NULL);
+
+    XFixesSelectBarrierInput (Display (), DefaultRootWindow (Display ()),
+                              XFixesBarrierHitNotifyMask);
+
+    int x = 20, y = 100, dx = -40, dy = 0;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    /* Generate 5 barrier events */
+    for (int i = 0; i < 5; ++i) {
+        XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    }
+
+    int barrierEventCount = 0;
+    XFlush (Display ());
+    ASSERT_TRUE (WaitForXEvent ())<<"Timed out waiting to receive X event";
+    while (XPending (Display ())) {
+        XEvent e;
+        XNextEvent (Display (), &e);
+        switch (e.xany.type - fixes_eventbase) {
+            case XFixesBarrierNotify:
+                barrierEventCount++;
+                break;
+        }
+    }
+    ASSERT_EQ (5, barrierEventCount);
+}
